<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>2</id>
  <title>Combined summary - Chain pruning</title>
  <updated>2023-05-19T18:40:09.540731+00:00</updated>
  <author>
    <name>Pieter Wuille 2014-04-10 18:32:40</name>
  </author>
  <author>
    <name>Pieter Wuille 2014-04-10 16:59:54</name>
  </author>
  <author>
    <name>Gregory Maxwell 2014-04-10 12:10:35</name>
  </author>
  <author>
    <name>Gregory Maxwell 2014-04-10 22:33:36</name>
  </author>
  <author>
    <name>Pieter Wuille 2014-04-10 20:29:40</name>
  </author>
  <link href="bitcoin-dev/April_2014/005222_Chain-pruning.xml" rel="alternate"/>
  <link href="bitcoin-dev/April_2014/005217_Chain-pruning.xml" rel="alternate"/>
  <link href="bitcoin-dev/April_2014/005206_Chain-pruning.xml" rel="alternate"/>
  <link href="bitcoin-dev/April_2014/005229_Chain-pruning.xml" rel="alternate"/>
  <link href="bitcoin-dev/April_2014/005225_Chain-pruning.xml" rel="alternate"/>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>2</id>
    <title>Combined summary - Chain pruning</title>
    <updated>2023-05-19T18:40:09.540731+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-April/005222.html" rel="alternate"/>
    <summary>Several Bitcoin developers discussed various aspects of the blockchain and full node security in email exchanges. One developer suggested forming "superblocks" that are chained together to serve specific parts of the blockchain, allowing participants with limited resources to serve portions of the blockchain. However, the actual state of the blockchain is the UTXO set, which is all that's needed to validate future blocks. The problem is you can't just give someone the UTXO set and expect them to trust it, as there is no way to prove that it was the result of processing the actual blocks. In essence, combining both ideas means you get "superblocks" (the UTXO set is essentially the summary of the result of all past blocks), in a way that is less-than-currently-but-perhaps-still-acceptably-validated. The discussion then moved to the topic of a fixed range of blocks or a static node that always serves only a specific number of blocks. However, the major problems that checkpoints solve can be addressed in other more efficient ways that don't result in putting trust in third parties. With headers first synchronization, you can embed software knowledge that the longest chain is "at least this long" to prevent isolation attacks. You can also do randomized validation of the deeply buried old history for performance, instead of constantly depending on 'trusted parties' to update software or it gets slower over time, and locally save your own validation fingerprints so if you need to reinitialize data you can remember what you've checked so far by hash.In another part of the exchange, a developer pointed out that a 51% attack can make you believe you were paid, while you weren't. Full node security right now validates everything - there is no way you can ever be made to believe something invalid. The only attacks against it are about which version of valid history eventually gets chosen. If you trust hashrate for determining which UTXO set is valid, a 51% attack becomes worse in that you can be made to believe a version of history which is, in fact, invalid. However, fraud proofs are a cool idea, which allows leveraging some "herd immunity" in the system (assuming you'll be told about invalid data you received without actually validating it).</summary>
    <published>2014-04-10T18:32:40+00:00</published>
  </entry>
</feed>
