<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>2</id>
  <title>Combined summary - Electrum 2.0 has been tagged</title>
  <updated>2023-05-19T19:51:07.718316+00:00</updated>
  <author>
    <name>Gregory Maxwell 2015-03-12 04:09:44</name>
  </author>
  <author>
    <name>Gregory Maxwell 2015-03-12 00:11:24</name>
  </author>
  <author>
    <name>Gregory Maxwell 2015-03-11 19:46:22</name>
  </author>
  <link href="bitcoin-dev/March_2015/007664_Electrum-2-0-has-been-tagged.xml" rel="alternate"/>
  <link href="bitcoin-dev/March_2015/007658_Electrum-2-0-has-been-tagged.xml" rel="alternate"/>
  <link href="bitcoin-dev/March_2015/007648_Electrum-2-0-has-been-tagged.xml" rel="alternate"/>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>2</id>
    <title>Combined summary - Electrum 2.0 has been tagged</title>
    <updated>2023-05-19T19:51:07.718316+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-March/007664.html" rel="alternate"/>
    <summary>The conversation revolves around standardizing the wallets to reduce incompatibility and prevent wallet-specific algorithms from containing weaknesses. The advantages of not being forced to use an old wallet to send coins when switching wallets include maintaining transaction history, emergency transition when a wallet has a serious bug, and web wallet with server down. However, loading a key doesn't keep transaction history unless the wallet can understand or infer metadata about the transactions. To preserve historical information, reporting from the wallet in question is the best way. It is suggested that for an emergency transition, the user is better off with an explicit unstructured mass private key export and a sweep function. It is unfortunate that the ecosystem is failing to standardize on phrase handling, and several BIPs in this space are flawed, which makes cross-importing keys confusing or breaking something. Compatibility is only straightforward when the feature set is as limited as possible. Even if you're trying to be fairly generic, the testing overhead for all possible strategies and structures is large. Expecting compatibility here would be like expecting two large commercial accounting packages to support the same internal file formats.Ultimately, the most fundamental compatibility is guaranteed by sending funds to another wallet, which always works and guarantees that users are never locked into a single wallet. The conversation concludes by stating that there are genuine principled disagreements on how some things should be done and that we cannot expect complete compatibility but we can hope to minimize gratuitous incompatibility and reduce outright flawed constructions.</summary>
    <published>2015-03-12T04:09:44+00:00</published>
  </entry>
</feed>
