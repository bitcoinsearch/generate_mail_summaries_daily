<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>2</id>
  <title>Combined summary - Squashing redundant tx data in blocks on the wire</title>
  <updated>2023-05-19T19:04:25.492871+00:00</updated>
  <author>
    <name>Gregory Maxwell 2014-07-31 21:29:40</name>
  </author>
  <author>
    <name>Gregory Maxwell 2014-07-19 06:48:18</name>
  </author>
  <author>
    <name>Gregory Maxwell 2014-07-19 01:25:44</name>
  </author>
  <author>
    <name>Gregory Maxwell 2014-07-17 23:34:21</name>
  </author>
  <author>
    <name>Gregory Maxwell 2014-07-31 23:18:38</name>
  </author>
  <author>
    <name>Gregory Maxwell 2014-07-31 21:51:23</name>
  </author>
  <link href="bitcoin-dev/July_2014/006391_Squashing-redundant-tx-data-in-blocks-on-the-wire.xml" rel="alternate"/>
  <link href="bitcoin-dev/July_2014/006320_Squashing-redundant-tx-data-in-blocks-on-the-wire.xml" rel="alternate"/>
  <link href="bitcoin-dev/July_2014/006315_Squashing-redundant-tx-data-in-blocks-on-the-wire.xml" rel="alternate"/>
  <link href="bitcoin-dev/July_2014/006291_Squashing-redundant-tx-data-in-blocks-on-the-wire.xml" rel="alternate"/>
  <link href="bitcoin-dev/July_2014/006395_Squashing-redundant-tx-data-in-blocks-on-the-wire.xml" rel="alternate"/>
  <link href="bitcoin-dev/July_2014/006393_Squashing-redundant-tx-data-in-blocks-on-the-wire.xml" rel="alternate"/>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>2</id>
    <title>Combined summary - Squashing redundant tx data in blocks on the wire</title>
    <updated>2023-05-19T19:04:25.492871+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-July/006391.html" rel="alternate"/>
    <summary>The topic of discussion is a problem similar to set reconciliation, where one peer has a set of transactions and another peer has a different set. The focus is on minimizing data transfer while optimizing round complexity. A proposal to use forward error correction (FEC) to transfer with low data transfer and negligible probability of needing a round-trip was mentioned. However, there is overhead involved, and it may not be the best solution. Another suggestion was to keep at least the last N sent in each direction to bound memory usage. The FEC still allows filling in missing transactions without knowing in advance what will be missing. There is also a discussion about the benefits of implementing FEC-based mempool synchronization separately from channel-memory based index-coding. Communication overhead of transmitting a transaction list is discussed, but it can be communicated in a space roughly equal to the size of the difference in sets plus coding the permutation from the permissible orderings. The FEC can still fill in the missing transactions without knowing in advance what will be missing. Finally, the idea of using part of a cryptographic permutation as the key is presented, which means that for unknown transactions, the transmission of the new unknown keys is always goodput, which doesn't add overhead.</summary>
    <published>2014-07-31T21:29:40+00:00</published>
  </entry>
</feed>
