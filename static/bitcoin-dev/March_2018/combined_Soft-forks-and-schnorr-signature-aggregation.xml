<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>2</id>
  <title>Combined summary - Soft-forks and schnorr signature aggregation</title>
  <updated>2023-05-20T05:23:52.254959+00:00</updated>
  <author>
    <name>Anthony Towns 2018-03-21 04:06:18</name>
  </author>
  <author>
    <name>Anthony Towns 2018-03-27 06:34:33</name>
  </author>
  <author>
    <name>Anthony Towns 2018-03-21 11:21:19</name>
  </author>
  <link href="bitcoin-dev/March_2018/015838_Soft-forks-and-schnorr-signature-aggregation.xml" rel="alternate"/>
  <link href="bitcoin-dev/March_2018/015849_Soft-forks-and-schnorr-signature-aggregation.xml" rel="alternate"/>
  <link href="bitcoin-dev/March_2018/015839_Soft-forks-and-schnorr-signature-aggregation.xml" rel="alternate"/>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>2</id>
    <title>Combined summary - Soft-forks and schnorr signature aggregation</title>
    <updated>2023-05-20T05:23:52.255956+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-March/015838.html" rel="alternate"/>
    <summary>At the recent core-dev-tech meeting, there was a lot of discussion about Schnorr signatures as well as key and signature aggregation. Although signature aggregation is favorable in many ways, combining it with the possibility of soft-forking new opcodes via OP_RETURN_VALID opcodes may cause trouble. The latter has the potential for a serious pitfall that could lead to a hard fork.As an example, imagine introducing a covenant opcode that pulls a potentially complicated condition from the stack, checks it against the transaction, and then pushes 1 or 0 back onto the stack indicating compliance. If this happens, any aggregatable signature operations that occur after the covenant opcode must go into separate buckets, making it impossible to process them correctly with old nodes.There are two possible solutions to this problem. One solution involves being very careful and ensuring that any aggregated signatures that are conditional on a redefined RETURN_VALID opcode go into later buckets. However, this approach is complicated to implement correctly, and essentially doubles the number of buckets you have to potentially deal with every time you soft fork in a new opcode. Alternatively, forget about the hope that RETURN_VALID opcodes could be converted to anything, and just reserve OP_NOP opcodes and convert them to CHECK_foo_VERIFY opcodes just as we have been doing, and when we can't do that bump the segwit witness version for a whole new version of the script.Another solution is to rewrite scripts in ways that avoid the problem. In particular, the problem only occurs if you do aggregatable CHECKSIG operations after "RETURN_VALID" -- if you do all the CHECKSIGs first, then there's no problem. So you could rewrite the script in a way that does all the CHECKSIGs before any other operation. This solution requires scriptwriters to be clever enough to write their scripts in a specific way.A simpler solution would be to make dedicated opcodes to help with "do all the signatures first" and "check the committed execution path against reality" steps. This approach involves creating two new opcodes, namely CHECK_AGGSIG_VERIFY and CHECK_AGG_SIGNERS. The first one takes a count of pubkeys, N pubkeys, a bitmask of which pubkeys are required to sign, a bitmask of which optional pubkeys have signed, and M sighashes for the pubkeys corresponding to the set bits of (REQ|OPT). It fails if the aggregated signature doesn't pass or if a redefined RETURN_VALID opcode has already been seen. The second opcode takes a bitmask of which pubkeys are being queried and pushes to the stack 1 or 0 based on whether (REQ|OPT) &amp; B == B? 1:0.Bram Cohen, a well-known developer, suggested on Bitcoin-dev mailing list that RETURN_VALID opcodes should be used to introduce new opcode and soft-forking it, which will allow any new opcode to be introduced and different new opcodes to take effect in concurrent soft-forks. Bram also suggested that unused opcodes should be reclaimed as RETURN_VALID. The parsing weirdness of all the unclaimed opcodes is interesting because everything in an IF clause needs to be parsed in order to find where the ELSE is.The author discusses various approaches to implementing M-of-N aggregated multisig in Bitcoin scripts. One approach involves using the CHECKMULTISIG and CHECKMULTISIGVERIFY opcodes for signature aggregation, while another involves using Merkleized Abstract Syntax Trees (MAST) to commit to an execution path. The author favors a hybrid approach that includes introducing a new segwit witness version with support for Schnorr signature verification and MAST scripts, as well as a new opcode called CHECK_AGG_SIG_VERIFY for aggregating signatures. The author also suggests bundling a hard-fork upgrade in the future to allow spending of existing p2pk/p2pkh UTXOs via v2-aggregated-signature. However, there are still numerous considerations to be made regarding the implementation of signature aggregation, such as the consensus-critical aggregation algorithm and p2p impact.The discussion is about the implementation of new bitcoin script opcodes and their effects on transactions. The conversation focuses on different options, including adding new opcodes or modifying existing ones. One option suggested is to cause a RETURN_VALID at parse time, which would prevent unknown opcodes from causing execution failures. Another suggestion is to add an opcode for multisig verification, which aggregates public keys and messages to produce a single signature. The Bellare-Neven verification algorithm is discussed as a possible solution. Finally, the implications of allowing pre-softfork nodes to not do any checking are discussed, with the conclusion that such a situation could allow for theft of funds.</summary>
    <published>2018-03-21T04:06:18+00:00</published>
  </entry>
</feed>
